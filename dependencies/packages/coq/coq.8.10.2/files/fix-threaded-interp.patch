diff --git a/Makefile.install b/Makefile.install
index 51017b7c3a..e2fbdb7827 100644
--- a/Makefile.install
+++ b/Makefile.install
@@ -125,7 +125,7 @@ ifndef CUSTOM
 endif
 ifeq ($(BEST),opt)
 	$(INSTALLLIB) $(LIBCOQRUN) $(FULLCOQLIB)/kernel/byterun
-	$(INSTALLSH) $(FULLCOQLIB) $(PLUGINSOPT)
+	#$(INSTALLSH) $(FULLCOQLIB) $(PLUGINSOPT)
 endif
 # csdpcert is not meant to be directly called by the user; we install
 # it with libraries
diff --git a/kernel/byterun/coq_fix_code.c b/kernel/byterun/coq_fix_code.c
index 0865487c98..34f0578f65 100644
--- a/kernel/byterun/coq_fix_code.c
+++ b/kernel/byterun/coq_fix_code.c
@@ -12,7 +12,7 @@
    for fast computation of bounded (31bits) integers */
 
 #include <stdio.h>
-#include <stdlib.h> 
+#include <stdlib.h>
 #include <stdint.h>
 #include <caml/config.h>
 #include <caml/misc.h>
@@ -26,6 +26,7 @@
 #ifdef THREADED_CODE
 char ** coq_instr_table;
 char * coq_instr_base;
+#endif /*  THREADED_CODE */
 int arity[STOP+1];
 
 void init_arity () {
@@ -42,7 +43,7 @@ void init_arity () {
     arity[GETFIELD0]=arity[GETFIELD1]=arity[SETFIELD0]=arity[SETFIELD1]=
     arity[CONST0]=arity[CONST1]=arity[CONST2]=arity[CONST3]=
     arity[PUSHCONST0]=arity[PUSHCONST1]=arity[PUSHCONST2]=arity[PUSHCONST3]=
-    arity[ACCUMULATE]=arity[STOP]=arity[MAKEPROD]= 
+    arity[ACCUMULATE]=arity[STOP]=arity[MAKEPROD]=
     arity[ADDINT63]=arity[SUBINT63]=arity[LTINT63]=arity[LEINT63]=
     arity[ISINT]=arity[AREINT2]=0;
   /* instruction with one operand */
@@ -67,14 +68,12 @@ void init_arity () {
   /* instruction with two operands */
   arity[APPTERM]=arity[MAKEBLOCK]=arity[CLOSURE]=
   arity[PROJ]=2;
-  /* instruction with four operands */ 
+  /* instruction with four operands */
   arity[MAKESWITCHBLOCK]=4;
   /* instruction with arbitrary operands */
   arity[CLOSUREREC]=arity[CLOSURECOFIX]=arity[SWITCH]=0;
 }
 
-#endif /*  THREADED_CODE */
-
 
 void * coq_stat_alloc (asize_t sz)
 {
@@ -150,9 +149,9 @@ value coq_tcode_of_code (value code) {
   q = coq_stat_alloc(len);
   Code_val(res) = q;
   len /= sizeof(opcode_t);
-  for (p = (code_t)code; p < (code_t)code + len; /*nothing*/) {  
+  for (p = (code_t)code; p < (code_t)code + len; /*nothing*/) {
     opcode_t instr;
-    COPY32(&instr,p); 
+    COPY32(&instr,p);
     p++;
     if (instr < 0 || instr > STOP){
       instr = STOP;
@@ -174,7 +173,7 @@ value coq_tcode_of_code (value code) {
       for(i=1; i<n; i++) { COPY32(q,p); p++; q++; };
     } else {
       uint32_t i, ar;
-      ar = arity[instr]; 
+      ar = arity[instr];
       for(i=0; i<ar; i++) { COPY32(q,p); p++; q++; };
     }
   }
diff --git a/kernel/byterun/coq_fix_code.h b/kernel/byterun/coq_fix_code.h
index 5a233e6178..df09ca8c7a 100644
--- a/kernel/byterun/coq_fix_code.h
+++ b/kernel/byterun/coq_fix_code.h
@@ -18,12 +18,13 @@ void * coq_stat_alloc (asize_t sz);
 #ifdef THREADED_CODE
 extern char ** coq_instr_table;
 extern char * coq_instr_base;
-void init_arity();
 #define VALINSTR(instr) ((opcode_t)(coq_instr_table[instr] - coq_instr_base))
 #else
 #define VALINSTR(instr) instr
 #endif /*  THREADED_CODE */
 
+void init_arity();
+
 #define Is_instruction(pc,instr) (*pc == VALINSTR(instr))
 
 value coq_tcode_of_code(value code);
diff --git a/kernel/byterun/coq_memory.c b/kernel/byterun/coq_memory.c
index a1c49bee95..4a87e98706 100644
--- a/kernel/byterun/coq_memory.c
+++ b/kernel/byterun/coq_memory.c
@@ -9,7 +9,7 @@
 /***********************************************************************/
 
 #include <stdio.h>
-#include <string.h> 
+#include <string.h>
 #include <caml/alloc.h>
 #include <caml/address_class.h>
 #include "coq_gc.h"
@@ -31,7 +31,7 @@ int drawinstr;
 
 long coq_saved_sp_offset;
 value * coq_sp;
-/* Some predefined pointer code */ 
+/* Some predefined pointer code */
 code_t accumulate;
 
 /* functions over global environment */
@@ -80,7 +80,7 @@ void init_coq_stack()
   coq_stack_high = coq_stack_low + Coq_stack_size / sizeof (value);
   coq_stack_threshold = coq_stack_low + Coq_stack_threshold / sizeof(value);
   coq_max_stack_size = Coq_max_stack_size;
-}  
+}
 
 void init_coq_interpreter()
 {
@@ -96,14 +96,12 @@ value init_coq_vm(value unit) /* ML */
     fprintf(stderr,"already open \n");fflush(stderr);}
   else {
     drawinstr=0;
-#ifdef THREADED_CODE   
     init_arity();
-#endif /* THREADED_CODE */
     /* Allocate the table of global and the stack */
     init_coq_stack();
     /* Initialing the interpreter */
     init_coq_interpreter();
-    
+
     /* Some predefined pointer code.
      * It is typically contained in accumulator blocks whose tag is 0 and thus
      * scanned by the GC, so make it look like an OCaml block. */
@@ -117,7 +115,7 @@ value init_coq_vm(value unit) /* ML */
       coq_prev_scan_roots_hook = scan_roots_hook;
     scan_roots_hook = coq_scan_roots;
     coq_vm_initialized = 1;
-  } 
+  }
   return Val_unit;;
 }
 
